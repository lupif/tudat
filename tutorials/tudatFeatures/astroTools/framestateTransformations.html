

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1.1. Frame/State Transformations &mdash; TU Delft Astrodynamic Toolbox  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="TU Delft Astrodynamic Toolbox  documentation" href="../../../index.html"/>
        <link rel="up" title="1. Basic Astrodynamics Tools" href="index.html"/>
        <link rel="next" title="2. Basic Mathematics Tools" href="../mathTools/index.html"/>
        <link rel="prev" title="1. Basic Astrodynamics Tools" href="index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> TU Delft Astrodynamic Toolbox
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Start Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Tutorials and Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../prerequiredKnowledge/index.html">Getting Started with Tudat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../applicationWalkthroughs/index.html">Application Walkthroughs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Tudat Libraries</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">1. Basic Astrodynamics Tools</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">1.1. Frame/State Transformations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../mathTools/index.html">2. Basic Mathematics Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../environmentSetup/index.html">3. Environment Set-up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accelerationSetup/index.html">4. Acceleration Set-Up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../propagationSetup/index.html">5. Simulator Set-Up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../estimationSetup/index.html">6. Estimation Set-Up</a></li>
<li class="toctree-l3"><a class="reference internal" href="../otherLibraries/index.html">7. Other Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../optimizationTools/index.html">8. Optimization tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../jsonInterface/index.html">JSON Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../matlabInterface/index.html">MATLAB Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../developerGuide/index.html">Developer Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TU Delft Astrodynamic Toolbox</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Tutorials and Documentation</a> &raquo;</li>
        
          <li><a href="../index.html">Tudat Libraries</a> &raquo;</li>
        
          <li><a href="index.html">1. Basic Astrodynamics Tools</a> &raquo;</li>
        
      <li>1.1. Frame/State Transformations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/tutorials/tudatFeatures/astroTools/framestateTransformations.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="frame-state-transformations">
<span id="tudatfeaturesframestatetransformations"></span><h1>1.1. Frame/State Transformations<a class="headerlink" href="#frame-state-transformations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="state-type-conversions">
<h2>1.1.1. State type conversions<a class="headerlink" href="#state-type-conversions" title="Permalink to this headline">¶</a></h2>
<p>Depending on your application, you will be using any of a number of state (position and velocity) representations. In Tudat, conversions involving the following state representations are available:</p>
<ul class="simple">
<li>Cartesian elements.</li>
<li>Keplerian elements.</li>
<li>Spherical-orbital elements.</li>
<li>Modified Equinoctial elements.</li>
<li>Unified State Model elements.</li>
</ul>
<p>For each of these element types, conversions to/from Cartesian elements are available. Converting between two element types, where neither is Cartesian, will typically involve first transforming to Cartesian elements, and then transforming to your output state type. For each state type, the physical meaning of each of the elements is defined in the&nbsp;<code class="docutils literal"><span class="pre">statevectorIndices.h</span></code>&nbsp;file. In this file, you see for instance:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Keplerian elements indices.</span>
<span class="k">enum</span> <span class="n">KeplerianElementIndices</span>
<span class="p">{</span>
<span class="n">semiMajorAxisIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="n">eccentricityIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="n">inclinationIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="n">argumentOfPeriapsisIndex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="n">longitudeOfAscendingNodeIndex</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="n">trueAnomalyIndex</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="n">semiLatusRectumIndex</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This indicates that, for instance the eccentricity is index 1 and the true anomaly is index 5. As a result, you can use the following to retrieve the eccentricity from a vector if Kepler elements:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Keplerian elements indices.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">keplerElements</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">currentEccentricity</span> <span class="o">=</span> <span class="n">keplerElements</span><span class="p">(</span> <span class="n">orbital_element_conversions</span><span class="o">::</span><span class="n">eccentricityIndex</span> <span class="p">);</span>
</pre></div>
</div>
<p>or alternatively:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Keplerian elements indices.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">keplerElements</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">currentEccentricity</span> <span class="o">=</span> <span class="n">keplerElements</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
</pre></div>
</div>
<p>which yields the exact same result.</p>
<p>In the definition of the <code class="docutils literal"><span class="pre">KeplerianElementIndices</span></code> enum, you can see something peculiar: both <code class="docutils literal"><span class="pre">semiMajorAxisIndex</span></code> and <code class="docutils literal"><span class="pre">semiLatusRectumIndex</span></code> are defined as index 0. The latter option is only applicable when the orbit is parabolic (when the eccentricity is 1.0). That is, if the orbit is parabolic, element 0 does not represent the semi-major axis (as it is not defined) but the semi-latus rectum. Below, we list the details of the implementation of each of these state types in Tudat:</p>
<div class="section" id="kepler-elements">
<h3>1.1.1.1. Kepler elements<a class="headerlink" href="#kepler-elements" title="Permalink to this headline">¶</a></h3>
<p>The Kepler elements are the standard orbital elements used in classical celestial mechanics, with the element indices shown above.
Converting to/from Cartesian state requires an additional piece of information in addition to the state itself: the gravitational parameter of the body w.r.t. the Keplerian elements are defined. Conversion to/from Cartesian elements is done as</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">centralBodyGravitationalParameter</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">keplerianState</span> <span class="o">=</span> <span class="n">convertCartesianToKeplerianElements</span><span class="p">(</span> <span class="n">cartesianState</span><span class="p">,</span> <span class="n">centralBodyGravitationalParameter</span> <span class="p">);</span>
</pre></div>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">keplerianState</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">centralBodyGravitationalParameter</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="n">convertKeplerianToCartesianElements</span><span class="p">(</span> <span class="n">keplerianState</span><span class="p">,</span> <span class="n">centralBodyGravitationalParameter</span> <span class="p">);</span>
</pre></div>
</div>
<p>In the definition of the state elements, you will notice that element 5 is the true anomaly, not the eccentric or mean anomaly. Tudat also contains functions to convert to these alternative anomalies. Converting between true and eccentric anomaly is done as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">trueAnomaly</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">eccentricity</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">eccentricAnomaly</span> <span class="o">=</span> <span class="n">convertTrueAnomalyToEccentricAnomaly</span><span class="p">(</span> <span class="n">trueAnomaly</span><span class="p">,</span> <span class="n">eccentricity</span> <span class="p">);</span>
</pre></div>
</div>
<p>or directly from the orbital elements:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">keplerianState</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">eccentricAnomaly</span> <span class="o">=</span> <span class="n">convertTrueAnomalyToEccentricAnomaly</span><span class="p">(</span> <span class="n">keplerianState</span><span class="p">(</span> <span class="n">trueAnomalyIndex</span> <span class="p">),</span> <span class="n">keplerianState</span><span class="p">(</span> <span class="n">eccentricityIndex</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>Note that this function automatically identifies whether the orbit is elliptical or hyperbolic, and computes the associated eccentric anomaly. The function for the inverse operation is <code class="docutils literal"><span class="pre">convertEccentricAnomalyToTrueAnomaly</span></code>. Similarly, Tudat contains functions to convert from eccentric to mean anomaly (automatically checking whether the orbit is elliptical or hyperbolic):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">trueAnomaly</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">eccentricity</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">eccentricAnomaly</span> <span class="o">=</span> <span class="n">convertTrueAnomalyToEccentricAnomaly</span><span class="p">(</span> <span class="n">trueAnomaly</span><span class="p">,</span> <span class="n">eccentricity</span> <span class="p">);</span>
<span class="kt">double</span> <span class="n">meanAnomaly</span> <span class="o">=</span> <span class="n">convertEccentricAnomalyToMeanAnomaly</span><span class="p">(</span> <span class="n">eccentricAnomaly</span><span class="p">,</span> <span class="n">eccentricity</span> <span class="p">);</span>
</pre></div>
</div>
<p>The inverse operation, mean to eccentric anomaly, is done separately for hyperbolic and elliptical orbits, through the functions <code class="docutils literal"><span class="pre">convertMeanAnomalyToEccentricAnomaly</span></code> for elliptical and <code class="docutils literal"><span class="pre">convertMeanAnomalyToHyperbolicEccentricAnomaly</span></code> for hyperbolic orbits. In general, you will use them as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">meanAnomaly</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">eccentricity</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">eccentricAnomaly</span> <span class="o">=</span> <span class="n">convertMeanAnomalyToEccentricAnomaly</span><span class="p">(</span> <span class="n">eccentricity</span><span class="p">,</span> <span class="n">meanAnomaly</span> <span class="p">);</span>
</pre></div>
</div>
<p>However, this conversion involves the solution of an implicit algebraic equation, for which a root finder is used. Root finders are discussed in more detail&nbsp;here. When calling the function as in the above example, a <code class="xref py py-class docutils literal"><span class="pre">RootFinder</span></code> is created internally. However, in some cases you may want to specify your own root finder, as well as a first initial guess for the eccentric anomaly (which the root finder uses at its first iteration). When doing so, you create a pointer to a root finder object and pass it to the conversion function as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">meanAnomaly</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">eccentricity</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">initialGuess</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">RootFinder</span> <span class="o">&gt;</span> <span class="n">rootFinder</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">eccentricAnomaly</span> <span class="o">=</span> <span class="n">convertMeanAnomalyToEccentricAnomaly</span><span class="p">(</span> <span class="n">eccentricity</span><span class="p">,</span> <span class="n">meanAnomaly</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">initialGuess</span><span class="p">,</span> <span class="n">rootFinder</span> <span class="p">);</span>
</pre></div>
</div>
<p>where the argument <code class="docutils literal"><span class="pre">false</span></code> indicates that the user-specified initial guess is to be used. If you want to use a custom-defined root finder, but not an initial guess, use the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">meanAnomaly</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">eccentricity</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">RootFinder</span> <span class="o">&gt;</span> <span class="n">rootFinder</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">eccentricAnomaly</span> <span class="o">=</span> <span class="n">convertMeanAnomalyToEccentricAnomaly</span><span class="p">(</span> <span class="n">eccentricity</span><span class="p">,</span> <span class="n">meanAnomaly</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">TUDAT_NAN</span><span class="p">,</span> <span class="n">rootFinder</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="spherical-orbital-elements">
<h3>1.1.1.2. Spherical-orbital elements<a class="headerlink" href="#spherical-orbital-elements" title="Permalink to this headline">¶</a></h3>
<p>The spherical elements are typically used to denote the conditions in atmospheric flight. In most applications, they will be used to denote the state in a body-fixed frame. The details of the physical meaning of the elements is discussed&nbsp;here. The element indices in Tudat are the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Spherical orbital state element indices</span>
<span class="k">enum</span> <span class="n">SphericalOrbitalStateElementIndices</span>
<span class="p">{</span>
    <span class="n">radiusIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">latitudeIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">longitudeIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">speedIndex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">flightPathIndex</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">headingAngleIndex</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The spherical elements consist of 6 entries, with no additional information required for the conversion to/from Cartesian elements. The conversion from Cartesian to spherical elements is performed as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="p">....</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">sphericalState</span> <span class="o">=</span> <span class="n">convertCartesianToSphericalOrbitalState</span><span class="p">(</span> <span class="n">cartesianState</span> <span class="p">);</span>
</pre></div>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">sphericalState</span> <span class="o">=</span> <span class="p">....</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="n">convertSphericalOrbitalToCartesianState</span><span class="p">(</span> <span class="n">sphericalState</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="modified-equinoctial-elements">
<h3>1.1.1.3. Modified Equinoctial elements<a class="headerlink" href="#modified-equinoctial-elements" title="Permalink to this headline">¶</a></h3>
<p>The modified equinoctial elements are typically used for orbits with eccentricities near 0 or 1 and/or inclinations near 0 or <span class="math">\(\pi\)</span>. The element indices in Tudat are the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Modified equinoctial element vector indices.</span>
<span class="k">enum</span> <span class="n">ModifiedEquinoctialElementVectorIndices</span>
<span class="p">{</span>
    <span class="n">semiParameterIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">fElementIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">gElementIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hElementIndex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">kElementIndex</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">trueLongitudeIndex</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The modified equinoctial elements consists of 6 elements. The conversion to/from Cartesian elements requires the gravitation parameter of the body w.r.t. which the Modified Equinoctial elements are defined. Furthermore, a <code class="docutils literal"><span class="pre">bool</span></code> is used to indicate whether the singularity of this element set occurs for inclinations of 0 or <span class="math">\(\pi\)</span>. The conversion from Cartesian elements is done as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">centralBodyGravitationalParameter</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="n">convertCartesianToModifiedEquinoctial</span><span class="p">(</span> <span class="n">cartesianState</span><span class="p">,</span> <span class="n">centralBodyGravitationalParameter</span><span class="p">,</span> <span class="n">flipSingularityToZeroInclination</span> <span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">flipSingularityToZeroInlination</span></code> is optional for this conversion. If left empty, an overloaded function will determine whether this value is true or false based on the inclination of the orbit.</p>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">modifiedEquinoctialElements</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">centralBodyGravitationalParameter</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="n">convertModifiedEquinoctialToCartesian</span><span class="p">(</span> <span class="n">modifiedEquinoctialElements</span><span class="p">,</span> <span class="n">centralBodyGravitationalParameter</span><span class="p">,</span> <span class="n">flipSingularityToZeroInclination</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="unified-state-model-elements">
<h3>1.1.1.4. Unified State Model elements<a class="headerlink" href="#unified-state-model-elements" title="Permalink to this headline">¶</a></h3>
<p>The element indices for the Unified State Model elements in Tudat are the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//! Unified State Model indices.</span>
<span class="k">enum</span> <span class="n">UnifiedStateModelElementIndices</span>
<span class="p">{</span>
    <span class="n">CHodographIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Rf1HodographIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Rf2HodographIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">epsilon1QuaternionIndex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">epsilon2QuaternionIndex</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">epsilon3QuaternionIndex</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">etaQuaternionIndex</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The unified state model elements consists of 7 elements. Only the conversion to/from Keplerian elements is implemented. The conversion requires the gravitation parameter of the body w.r.t. which the Unified State Model elements are defined. The conversion from Keplerian elements is done as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">keplerianElements</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">centralBodyGravitationalParameter</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="n">convertKeplerianToUnifiedStateModelElements</span><span class="p">(</span> <span class="n">keplerianElements</span><span class="p">,</span> <span class="n">centralBodyGravitationalParameter</span> <span class="p">);</span>
</pre></div>
</div>
<p>Similarly, the inverse operation is done as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">unifiedStateModelElements</span> <span class="o">=</span> <span class="p">....</span>
<span class="kt">double</span> <span class="n">centralBodyGravitationalParameter</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">cartesianState</span> <span class="o">=</span> <span class="n">convertUnifiedStateElementsToKeplerian</span><span class="p">(</span> <span class="n">unifiedStateModelElements</span><span class="p">,</span> <span class="n">centralBodyGravitationalParameter</span> <span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="frame-transformations">
<h2>1.1.2. Frame transformations<a class="headerlink" href="#frame-transformations" title="Permalink to this headline">¶</a></h2>
<p>Every state, regardless of its representation is expressed with a particular origin and orientation. This is most easy to understand for Cartesian elements, where the origin represents the (0,0,0) position, and the orientation defines the direction of the x-, y- and z-axes. Below, we discuss how to perform these operations in Tudat.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not use the getCurrentState or getCurrentRotation functions in the body objects! These functions are used during numerical propagation, and calling them outside of the numerical propagation will generally not lead to meaningful results.</p>
</div>
<div class="section" id="frame-translations">
<h3>1.1.2.1. Frame translations<a class="headerlink" href="#frame-translations" title="Permalink to this headline">¶</a></h3>
<p>To change the origin of a Cartesian, one can simply add a Cartesian state that represents the difference between the original and the new origin. For instance, when transforming a vector (state of a vehicle) from Earth-centered to Moon-centered (keeping the orientation constant):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">vehicleCartesianStateInEarthCenteredFrame</span> <span class="o">=</span> <span class="p">....</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">moonCartesianStateInEarthCenteredFrame</span> <span class="o">=</span> <span class="p">....</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">vehicleCartesianStateInMoonCenteredFrame</span> <span class="o">=</span> <span class="n">vehicleCartesianStateInEarthCenteredFrame</span> <span class="o">+</span> <span class="n">moonCartesianStateInEarthCenteredFrame</span><span class="p">;</span>
</pre></div>
</div>
<p>The challenge here, of course, is determining the <code class="docutils literal"><span class="pre">moonCartesianStateInEarthCenteredFrame</span></code> vector. We provide a few ways in which to achieve this. When performing a numerical simulation using a set of&nbsp;body objects, you can use the following (asuming the the <code class="docutils literal"><span class="pre">bodyMap</span></code> contains both an Earth and Moon entry):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">NamedBodyMap</span> <span class="n">bodyMap</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">moonCartesianStateInEarthCenteredFrame</span> <span class="o">=</span> <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="s">&quot;Moon&quot;</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getStateInBaseFrameFromEphemeris</span><span class="p">(</span> <span class="n">currentTime</span> <span class="p">)</span> <span class="o">-</span>
      <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="s">&quot;Earth&quot;</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getStateInBaseFrameFromEphemeris</span><span class="p">(</span> <span class="n">currentTime</span> <span class="p">);</span>
</pre></div>
</div>
<p>You can also bypass the body map altogether, and use Spice to obtain the relative state. Note, however, that this will use whichever <code class="docutils literal"><span class="pre">spice</span></code> kernels you have loaded, and may not be consistent with the states you are using the bodies in your simulation.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">frameOrientation</span> <span class="o">=</span> <span class="s">&quot;J2000&quot;</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">moonCartesianStateInEarthCenteredFrame</span> <span class="o">=</span>
    <span class="n">spice_interface</span><span class="o">::</span><span class="n">getBodyCartesianStateAtEpoch</span><span class="p">(</span> <span class="s">&quot;Moon&quot;</span><span class="p">,</span> <span class="s">&quot;Earth&quot;</span><span class="p">,</span> <span class="n">frameOrientation</span><span class="p">,</span> <span class="s">&quot;NONE&quot;</span><span class="p">,</span> <span class="n">currentTime</span>
</pre></div>
</div>
<p>where the <code class="docutils literal"><span class="pre">NONE</span></code> arguments indicates that no light-time corrections are used, and the frame orientation denotes the orientation of the frame in which the relative state is returned.</p>
</div>
<div class="section" id="frame-rotations">
<h3>1.1.2.2. Frame rotations<a class="headerlink" href="#frame-rotations" title="Permalink to this headline">¶</a></h3>
<p>Rotating the frame in which a Cartesian state is expressed requires two pieces of information:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The rotation matrix from one frame to the other</li>
<li>The first time derivative of the rotation matrix from one frame to the other</li>
</ol>
</div></blockquote>
<p>Manually, the state may then be transformed as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">rotationToFrame</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">timeDerivativeOfRotationToFrame</span>  <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">originalState</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">rotatedState</span><span class="p">;</span>
<span class="n">rotatedState</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">=</span> <span class="n">rotationToFrame</span> <span class="o">*</span> <span class="n">originalState</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
<span class="n">rotatedState</span><span class="p">.</span><span class="n">segment</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">=</span> <span class="n">rotationToFrame</span> <span class="o">*</span> <span class="n">originalState</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">+</span> <span class="n">timeDerivativeOfRotationToFrame</span> <span class="o">*</span> <span class="n">originalState</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</pre></div>
</div>
<p>In many cases, however, your frame rotation will be from the inertial frame to a body-fixed frame. All information required for this is stored in <code class="docutils literal"><span class="pre">RotationalEphemeris</span></code> objects. This object contains a base (inertial) and target (body-fixed) frame and defines the rotation between the two. Assuming that you are using a body map to store your environment, you can transform the state from an inertial to a body-fixed frame as follows, for the example of transforming a vehicle’s Cartesian state from an inertial to the body-fixed frame of the Earth:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">NamedBodyMap</span> <span class="n">bodyMap</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">inertialState</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">bodyFixedState</span> <span class="o">=</span> <span class="n">transformStateToTargetFrame</span><span class="p">(</span> <span class="n">inertialState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="s">&quot;Earth&quot;</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getRotationalEphemeris</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>the inverse rotation is done as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">NamedBodyMap</span> <span class="n">bodyMap</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">bodyFixedState</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">inertialState</span> <span class="o">=</span> <span class="n">transformStateToGlobalFrame</span><span class="p">(</span> <span class="n">inertialState</span><span class="p">,</span> <span class="n">bodyFixedState</span><span class="p">,</span> <span class="n">bodyMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span> <span class="s">&quot;Earth&quot;</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">getRotationalEphemeris</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../mathTools/index.html" class="btn btn-neutral float-right" title="2. Basic Mathematics Tools" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="1. Basic Astrodynamics Tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Delft University of Technology.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header .arrow").click(function() {
            $(this).closest('.toggle').children().not(".header").toggle(400);
            $(this).toggleClass("open");
            // $(this).html() == "More" ? $(this).html('Less') : $(this).html('More');
        });
        $(".showall").click(function() {
            $(".toggle > *").show(400);
            $(".toggle .header .arrow").addClass("open");
        });
        $(".hideall").click(function() {
            $(".toggle > *").hide(400);
            $(".toggle .header").show(400);
            $(".toggle .header .arrow").removeClass("open");
        });
    });
</script>


</body>
</html>